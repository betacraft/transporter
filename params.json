{"name":"Transporter","tagline":"An abstraction library for transport frameworks","body":"## Transporter\r\n\r\nTransporter library allows to keep your business logic separate from the underlying communication framework\r\nbeing used in your system components. So it doesn't matter if you are using  raw sockets, netty4.x, netty3.x, socketio\r\nor websockets. Transporter is designed in a way that adding or switching between these frameworks is less painful and\r\nis with minimum code hit.\r\n\r\nThis library is in it's nascent phases and being actively developed in RainingClouds.\r\n\r\n\r\n## Architecture\r\n\r\n```\r\n                                              +------------+\r\n                               |              | raw socket |\r\n                               |              +------------+\r\n    +------------+             |              | netty 3.x  |\r\n    | Your       |      +------+------+       +------------+\r\n    | Business   |  <-> | Transporter |  <->  | netty 4.x  |\r\n    | Logic      |      +------+------+       +------------+\r\n    +------------+             |              |  socketio  |\r\n                               |              +------------+\r\n                               |              |    ...     |\r\n```\r\n\r\nSo ideally this library acts as an interface between your business logic and transport layer. Right now netty4x\r\nimplementation is available and soon netty3x will be pushed.\r\n\r\n## Components\r\n\r\n\r\n#### TransportServer\r\n\r\nContract for writing transport server\r\n\r\n```\r\npublic abstract class TransportServer {\r\n    /**\r\n     * Transport server listener to listen various events related with server lifecycle\r\n     */\r\n    public interface ITransportServerListener {\r\n        /**\r\n         * Callback called when server is closed\r\n         */\r\n        public void onClosed();\r\n    }\r\n\r\n    /**\r\n     * Constructor for the server with shutdown hook to cleanup properly before process shutsdown\r\n     */\r\n    protected TransportServer() {\r\n        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                close();\r\n            }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Method to start server\r\n     *\r\n     * @param hostname                hostname\r\n     * @param port                    port on which server needs to be started\r\n     * @param transportServerListener @ITransportServerListener listener to listen the state of the server\r\n     * @param transportSession        @ITransportSession session routine that will be associated with each connection received\r\n     *                                on this server\r\n     * @throws Exception throws exception if any during starting the server\r\n     */\r\n    public abstract void start(final String hostname, final int port,\r\n                               final ITransportServerListener transportServerListener, final ITransportSession transportSession)\r\n            throws Exception;\r\n\r\n    /**\r\n     * Method to close server\r\n     */\r\n    protected abstract void close();\r\n}\r\n```\r\nSample netty4x server:\r\n(for details refer netty4x project)\r\n```\r\npublic final class NettyTransportServer extends TransportServer {\r\n    /**\r\n     * Logger\r\n     */\r\n    private static final Logger logger = LoggerFactory.getLogger(NettyTransportServer.class);\r\n    /**\r\n     * Server config\r\n     */\r\n    private NettyTransportServerConfig serverConfig;\r\n\r\n    /**\r\n     * Constructor\r\n     *\r\n     * @param config netty server config\r\n     */\r\n    public NettyTransportServer(final NettyTransportServerConfig config) {\r\n        super();\r\n        this.serverConfig = config;\r\n    }\r\n\r\n\r\n    /**\r\n     * Starting server\r\n     *\r\n     * @param hostname                hostname\r\n     * @param port                    port on which server needs to be started\r\n     * @param transportServerListener @ITransportServerListener listener to listen the state of the server\r\n     * @param nettyTransportSession   @ITransportSession associated with each connection being received on this server\r\n     */\r\n    @Override\r\n    public void start(final String hostname, final int port, final ITransportServerListener transportServerListener,\r\n                      final ITransportSession nettyTransportSession) throws Exception {\r\n        try {\r\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\r\n            serverBootstrap.group(this.serverConfig.getBossGroup(), this.serverConfig.getWorkerGroup())\r\n                    .channel(NioServerSocketChannel.class)\r\n                    .childHandler(new ChannelInitializer() {\r\n                        /**\r\n                         * This method will be called once the {@link io.netty.channel.Channel} was registered. After the method returns this instance\r\n                         * will be removed from the {@link io.netty.channel.ChannelPipeline} of the {@link io.netty.channel.Channel}.\r\n                         *\r\n                         * @param ch the {@link io.netty.channel.Channel} which was registered.\r\n                         * @throws Exception is thrown if an error occours. In that case the {@link io.netty.channel.Channel} will be closed.\r\n                         */\r\n                        @Override\r\n                        protected void initChannel(Channel ch) throws Exception {\r\n                            ChannelPipeline sharablePipeline = ch.sharablePipeline();\r\n                            for (Map.Entry<String, ChannelHandler> pipelineEntry : serverConfig.getPipeline().entrySet()) {\r\n                                sharablePipeline.addLast(pipelineEntry.getKey(), pipelineEntry.getValue());\r\n                            }\r\n                            sharablePipeline.addLast(\"handler\", new NettyTransportSession(nettyTransportSession));\r\n                        }\r\n                    });\r\n            // setting up options\r\n            for (Map.Entry<ChannelOption, Object> entry : this.serverConfig.getChannelOptions().entrySet()) {\r\n                serverBootstrap.option(entry.getKey(), entry.getValue());\r\n            }\r\n            // setting up child options\r\n            for (Map.Entry<ChannelOption, Object> entry : this.serverConfig.getChildChannelOptions().entrySet()) {\r\n                serverBootstrap.childOption(entry.getKey(), entry.getValue());\r\n            }\r\n            // bind server\r\n            serverBootstrap.bind(hostname, port).sync().channel().closeFuture().sync().addListener(new ChannelFutureListener() {\r\n                @Override\r\n                public void operationComplete(ChannelFuture future) throws Exception {\r\n                    transportServerListener.onClosed();\r\n                }\r\n            });\r\n        } catch (ChannelException exception) {\r\n            exception.printStackTrace();\r\n            throw exception;\r\n        } catch (InterruptedException exception) {\r\n            exception.printStackTrace();\r\n            throw exception;\r\n        } catch (Exception exception) {\r\n            throw exception;\r\n        } finally {\r\n            this.serverConfig.getBossGroup().shutdownGracefully();\r\n            this.serverConfig.getWorkerGroup().shutdownGracefully();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method to close server\r\n     */\r\n    @Override\r\n    protected void close() {\r\n        this.serverConfig.getBossGroup().shutdownGracefully();\r\n        this.serverConfig.getWorkerGroup().shutdownGracefully();\r\n    }\r\n}\r\n```\r\n\r\n#### ITransportClient\r\n\r\nContract for writing client.\r\n\r\n```\r\npublic interface ITransportClient<M> {\r\n    /**\r\n     * Method to initialize connection with @ITransportServer or other server\r\n     *\r\n     * @param host             hostname\r\n     * @param port             port\r\n     * @param transportSession @TransportSession to listen to the events associated wtih session\r\n     */\r\n    public void connect(final String host, final int port, TransportSession<M> transportSession);\r\n}\r\n```\r\n\r\n#### ITransportSession\r\n\r\nContract for associating with a connection.\r\n\r\n```\r\npublic interface ITransportSession<M> {\r\n\r\n    /**\r\n     * Callback called when connection is received in session\r\n     *\r\n     * @param channel @TransportChannel associated with this session\r\n     */\r\n    public void onConnected(TransportChannel channel);\r\n\r\n    /**\r\n     * Callback called when connection is disconnected\r\n     */\r\n    public void onDisconnected();\r\n\r\n    /**\r\n     * Callback called when error is caused in session\r\n     *\r\n     * @param cause Error cause\r\n     */\r\n    public void onError(Throwable cause);\r\n\r\n    /**\r\n     * Callback called when data is available\r\n     *\r\n     * @param data data\r\n     */\r\n    public void onData(M data);\r\n}\r\n\r\n```\r\n\r\n### Info\r\n\r\nFor any other help or info, you can mail us at akshay@rainingclouds.com.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}